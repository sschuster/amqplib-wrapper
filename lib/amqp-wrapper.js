// Generated by CoffeeScript 1.7.1
(function() {
  var AmqpWrapper, BindingAssertion, ExchangeAssertion, ExchangeSubscription, QueueAssertion, QueueSubscription, amqplib, whenlib, _ref, _ref1;

  amqplib = require("amqplib");

  whenlib = require("when");

  _ref = require("./assertion"), ExchangeAssertion = _ref.ExchangeAssertion, QueueAssertion = _ref.QueueAssertion, BindingAssertion = _ref.BindingAssertion;

  _ref1 = require("./subscription"), QueueSubscription = _ref1.QueueSubscription, ExchangeSubscription = _ref1.ExchangeSubscription;

  module.exports.reconnectTimeout = 1000;

  module.exports.AmqpWrapper = AmqpWrapper = (function() {
    function AmqpWrapper(config) {
      this.readyPromise = null;
      this.clientPromise = null;
      this.sharedChannelPromise = null;
      this.config = null;
      this.assertions = [];
      this.subscriptions = {};
      this.updateConfig(config);
    }

    AmqpWrapper.prototype.updateConfig = function(config) {
      if (config) {
        this.config = config;
      }
      if (this.clientPromise) {
        return this.disconnect();
      } else {
        return this.readyPromise = whenlib.promise((function(_this) {
          return function(resolve, reject, notify) {
            var amqpUrl, host;
            host = _this.config.host[Math.floor(Math.random() * _this.config.host.length)];
            amqpUrl = "amqp://" + _this.config.user + ":" + _this.config.password + "@" + host + ":" + _this.config.port + "/" + (encodeURIComponent(_this.config.vhost));
            _this.clientPromise = amqplib.connect(amqpUrl);
            return _this.clientPromise.then(function(client) {
              client.on("close", function() {
                return setTimeout(function() {
                  _this.clientPromise = null;
                  return _this.updateConfig();
                }, module.exports.reconnectTimeout);
              });
              client.on("error", function() {});
              _this.sharedChannelPromise = client.createChannel();
              return _this.sharedChannelPromise.then(function(channel) {
                var assertion;
                channel.on("error", function(err) {
                  return _this.disconnect();
                });
                return whenlib.all((function() {
                  var _i, _len, _ref2, _results;
                  _ref2 = this.assertions;
                  _results = [];
                  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                    assertion = _ref2[_i];
                    _results.push(assertion.execute(channel));
                  }
                  return _results;
                }).call(_this)).then(function() {
                  var queueName, subscription, _ref2;
                  _ref2 = _this.subscriptions;
                  for (queueName in _ref2) {
                    subscription = _ref2[queueName];
                    subscription.setClient(client);
                  }
                  return resolve(channel);
                }).otherwise(function(err) {
                  setTimeout(function() {
                    return _this.disconnect();
                  }, module.exports.reconnectTimeout);
                  return reject(err);
                });
              }).otherwise(function(err) {
                setTimeout(function() {
                  return _this.disconnect();
                }, module.exports.reconnectTimeout);
                return reject(err);
              });
            }).otherwise(function(err) {
              setTimeout(function() {
                _this.clientPromise = null;
                return _this.updateConfig();
              }, module.exports.reconnectTimeout);
              return reject(err);
            });
          };
        })(this));
      }
    };

    AmqpWrapper.prototype.disconnect = function() {
      if (this.clientPromise) {
        this.clientPromise.then((function(_this) {
          return function(client) {
            var closePromises, queueName, subscription;
            closePromises = (function() {
              var _ref2, _results;
              _ref2 = this.subscriptions;
              _results = [];
              for (queueName in _ref2) {
                subscription = _ref2[queueName];
                _results.push(subscription.disconnect());
              }
              return _results;
            }).call(_this);
            closePromises.push(whenlib(_this.sharedChannelPromise, function(channel) {
              return channel.close();
            }));
            _this.sharedChannelPromise = null;
            return whenlib.all(closePromises).ensure(function() {
              return client.close();
            });
          };
        })(this));
        return this.clientPromise = null;
      }
    };

    AmqpWrapper.prototype.shutdown = function() {
      this.updateConfig = function() {};
      return this.disconnect();
    };

    AmqpWrapper.prototype.assertExchange = function(name, type, options) {
      var assertion;
      assertion = new ExchangeAssertion(name, type, options);
      this.assertions.push(assertion);
      if (this.sharedChannelPromise) {
        return assertion.execute(this.sharedChannelPromise);
      }
    };

    AmqpWrapper.prototype.assertQueue = function(name, options) {
      var assertion;
      assertion = new QueueAssertion(name, options);
      this.assertions.push(assertion);
      if (this.sharedChannelPromise) {
        return assertion.execute(this.sharedChannelPromise);
      }
    };

    AmqpWrapper.prototype.assertBinding = function(queue, exchange, routingKey) {
      var assertion;
      assertion = new BindingAssertion(queue, exchange, routingKey);
      this.assertions.push(assertion);
      if (this.sharedChannelPromise) {
        return assertion.execute(this.sharedChannelPromise);
      }
    };

    AmqpWrapper.prototype.publish = function(msg, exchange, routingKey, options, cb) {
      var err;
      try {
        if (!(msg instanceof Buffer)) {
          if ((typeof msg) !== "string") {
            msg = JSON.stringify(msg);
          }
          msg = new Buffer(msg);
        }
      } catch (_error) {
        err = _error;
        if (cb) {
          cb(new Error("amqp-wrapper.publish couldn't serialize msg"));
        }
        return;
      }
      return this.readyPromise.then((function(_this) {
        return function(channel) {
          if (channel.publish(exchange, routingKey, msg, options)) {
            if (cb) {
              return cb(null);
            }
          } else {
            if (cb) {
              return cb(new Error("amqp-wrapper.publish encountered a full queue buffer"));
            }
          }
        };
      })(this)).otherwise(function(err) {
        if (cb) {
          return cb(err);
        }
      });
    };

    AmqpWrapper.prototype.subscribeQueue = function(queueName, options, subscriberCb) {
      if (!(queueName in this.subscriptions)) {
        this.subscriptions[queueName] = new QueueSubscription(queueName, options);
        if (this.clientPromise) {
          this.clientPromise.then((function(_this) {
            return function(client) {
              return _this.subscriptions[queueName].setClient(client);
            };
          })(this));
        }
      }
      return this.subscriptions[queueName].subscribe(subscriberCb);
    };

    AmqpWrapper.prototype.subscribeExchange = function(queueName, exchangeName, routingKey, options, subscriberCb) {
      if (!(queueName in this.subscriptions)) {
        this.subscriptions[queueName] = new ExchangeSubscription(queueName, exchangeName, routingKey, options);
        if (this.clientPromise) {
          this.clientPromise.then((function(_this) {
            return function(client) {
              return _this.subscriptions[queueName].setClient(client);
            };
          })(this));
        }
      }
      return this.subscriptions[queueName].subscribe(subscriberCb);
    };

    return AmqpWrapper;

  })();

}).call(this);
