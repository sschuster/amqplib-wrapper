// Generated by CoffeeScript 1.7.1
(function() {
  var ExchangeSubscription, Message, QueueSubscription, Subscription, whenlib,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  whenlib = require("when");

  Subscription = (function() {
    function Subscription(options) {
      this.options = options;
      this.client = null;
      this.channelPromise = null;
      this.subscribers = [];
    }

    Subscription.prototype.setClient = function(client) {
      this.client = client;
      if (this.subscribers.length > 0) {
        return this.connect();
      }
    };

    Subscription.prototype.connect = function() {
      if (!this.client) {
        return;
      }
      if (this.channelPromise) {
        this.disconnect();
      }
      this.channelPromise = this.client.createChannel();
      return this.channelPromise.then((function(_this) {
        return function(channel) {
          if ("prefetch" in _this.options) {
            channel.prefetch(_this.options["prefetch"]);
          }
          return channel.on("error", function(err) {});
        };
      })(this));
    };

    Subscription.prototype.disconnect = function() {
      var promise;
      promise = null;
      if (this.channelPromise) {
        promise = whenlib(this.channelPromise, function(channel) {
          return channel.close();
        });
        this.channelPromise = null;
      } else {
        promise = whenlib.promise((function(_this) {
          return function(resolve, reject, notify) {
            return resolve(true);
          };
        })(this));
      }
      return promise;
    };

    Subscription.prototype.subscribe = function(subscriberCb) {
      this.subscribers.push(subscriberCb);
      if (!this.channelPromise) {
        this.connect();
      }
      return {
        remove: (function(_this) {
          return function() {
            var subscriber;
            _this.subscribers = (function() {
              var _i, _len, _ref, _results;
              _ref = this.subscribers;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                subscriber = _ref[_i];
                if (subscriber !== subscriberCb) {
                  _results.push(subscriber);
                }
              }
              return _results;
            }).call(_this);
            if (_this.subscribers.length === 0) {
              return _this.disconnect();
            }
          };
        })(this)
      };
    };

    return Subscription;

  })();

  Message = (function() {
    function Message(channel, rawMessage) {
      this.channel = channel;
      this.rawMessage = rawMessage;
    }

    Message.prototype.ack = function() {
      var error;
      try {
        this.channel.ack(this.rawMessage);
        return true;
      } catch (_error) {
        error = _error;
        return false;
      }
    };

    Message.prototype.asString = function() {
      return this.rawMessage.content.toString();
    };

    Message.prototype.asJson = function() {
      return JSON.parse(this.asString());
    };

    return Message;

  })();

  module.exports.QueueSubscription = QueueSubscription = (function(_super) {
    __extends(QueueSubscription, _super);

    function QueueSubscription(queueName, options) {
      QueueSubscription.__super__.constructor.call(this, options);
      this.queueName = queueName;
    }

    QueueSubscription.prototype.connect = function() {
      QueueSubscription.__super__.connect.call(this);
      if (!this.channelPromise) {
        return;
      }
      return this.channelPromise.then((function(_this) {
        return function(channel) {
          return channel.consume(_this.queueName, function(rawMessage) {
            var message, subscriber, _i, _len, _ref, _results;
            message = new Message(channel, rawMessage);
            _ref = _this.subscribers;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              subscriber = _ref[_i];
              _results.push(subscriber(message));
            }
            return _results;
          }, _this.options);
        };
      })(this));
    };

    return QueueSubscription;

  })(Subscription);

  module.exports.ExchangeSubscription = ExchangeSubscription = (function(_super) {
    __extends(ExchangeSubscription, _super);

    function ExchangeSubscription(queueName, exchangeName, routingKey, options) {
      ExchangeSubscription.__super__.constructor.call(this, options);
      this.queueName = queueName;
      this.exchangeName = exchangeName;
      this.routingKey = routingKey;
    }

    ExchangeSubscription.prototype.connect = function() {
      ExchangeSubscription.__super__.connect.call(this);
      if (!this.channelPromise) {
        return;
      }
      return this.channelPromise.then((function(_this) {
        return function(channel) {
          channel.assertQueue(_this.queueName, {
            durable: false,
            exclusive: true,
            autoDelete: true
          });
          channel.bindQueue(_this.queueName, _this.exchangeName, _this.routingKey);
          return channel.consume(_this.queueName, function(rawMessage) {
            var message, subscriber, _i, _len, _ref, _results;
            message = new Message(channel, rawMessage);
            _ref = _this.subscribers;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              subscriber = _ref[_i];
              _results.push(subscriber(message));
            }
            return _results;
          }, _this.options);
        };
      })(this));
    };

    return ExchangeSubscription;

  })(Subscription);

}).call(this);
